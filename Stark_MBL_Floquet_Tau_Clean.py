import numpy as np
import scipy.sparse as spr
import scipy.sparse.linalg as splng
import matplotlib.pyplot as plt
from numba import jit

#calculate infinite size scaling exponents for system under clean driving

#calculate dimensionality for half filling
@jit
def Binom(n,k):
    ret = 1
    for i in range(min(k,n-k)):
        ret *= n-i
        ret /= i+1
    return ret

#state to label
@jit
def S2L(L,l_vec):
    N = L/2
    l_counter = 1
    n_counter = N
    for i in range(L):
        if l_vec[i] == 0:
            l_counter += Binom(L-(i+1),n_counter-1)
        if l_vec[i] == 1:
            n_counter -= 1
        if n_counter == 0:
            return l_counter

#label to state
@jit
def L2S(L,l):
    N = L/2
    n_counter = N
    l_counter = l
    l_vec = np.zeros(L)
    for i in range(L):
        binom = Binom(L-(i+1),n_counter-1)
        if n_counter == 0:
            l_vec[i] = 0
            continue
        if l_counter > binom:
            l_vec[i] = 0
            l_counter -= binom
            continue
        if l_counter <= binom:
            l_vec[i] = 1
            n_counter -= 1
    return l_vec

#state to label for subsystem
@jit
def S2L_Binary(vec,l):
    c = 0
    for i in range(l):
        if vec[l-1-i] == 1:
            c += 2**i
    return c

#generate states via hopping terms
def Hop(L,input):
    input = np.ndarray.astype(input,int) #input state
    output_lst = [] #appended list of output states
    for i in range(L-1):
        if input[i] == 1 and input[i+1] == 0: #hopping to the right
            output = np.copy(input)
            output[i] = 0
            output[i+1] = 1
            output_lst.append(output)
        if input[i] == 0 and input[i+1] == 1: #hopping to the left
            output = np.copy(input)
            output[i] = 1
            output[i+1] = 0
            output_lst.append(output)
    ns = np.shape(output_lst)[0] #number of output states
    return output_lst,ns

#diagonal elements of static Hamiltonian
def Diag(L,Dim,gamma,w,V):
    row = np.empty(Dim*L)
    col = np.empty(Dim*L)
    data = np.empty(Dim*L)
    nnz = 0
    for i in range(Dim):
        state = L2S(L,i+1) #select vector
        v = 0 #nearest-neighbour interaction counter
        g = 0 #field interaction counter
        h = 0 #disorder interaction counter
        for k in range(L):
            g = g-gamma*k*state[k] #count field interactions
            h = h+np.random.normal(0,w)*state[k] #count disorder interactions
        for k in range(L-1):
            v = v+V*state[k]*state[k+1] #count nearest-neighbour interactions
        row[nnz] = i #H[i,i] = g+h+v
        col[nnz] = i
        data[nnz] = g+h+v
        nnz += 1
    return spr.csc_matrix((data[:nnz],(row[:nnz],col[:nnz])),shape=(Dim,Dim))

#off-diagonal elements of static Hamiltonian
def Offdiag(L,Dim,J):
    row = np.empty(Dim*L)
    col = np.empty(Dim*L)
    data = np.empty(Dim*L)
    nnz = 0
    for i in range(Dim):
        input = L2S(L,i+1) #generate Fock state
        output_lst,ns = Hop(L,input) #generate new states via hopping
        for k in range(ns): #loop through all states generated by hopping
            output = output_lst[k] #select output state
            j = int(S2L(L,output)-1) #convert to label
            row[nnz] = i #H[i,j] = J
            col[nnz] = j
            data[nnz] = J
            nnz += 1
    return spr.csc_matrix((data[:nnz],(row[:nnz],col[:nnz])),shape=(Dim,Dim))

#calculate eigenvectors
def Eigenvectors(L,Dim,H_1,T_0,T_1,gamma,w,V,navg):
    f = int(np.ceil(navg/Dim))
    mW = np.zeros((f,Dim))
    I = np.zeros(f)
    U = np.zeros((f,Dim,Dim),dtype=complex)
    for x in range(f):
        H_0 = Diag(L,Dim,gamma,w,V) #diagonal part of Hamiltonian
        F = splng.expm(-1j*H_0*T_0)@splng.expm(-1j*H_1*T_1) #Floquet operator
        U[x] = np.linalg.eig(F.todense())[1] #calculate eigenvectors
    return np.array(U)

def IPR(U,q,Dim,navg):
    f = int(np.ceil(navg/Dim))
    I = np.zeros(f)
    for x in range(f):
        I[x] = np.mean(np.sum(np.abs(U[x])**(2*q),axis=1))
    return np.mean(I)

#scaling exponent
def Tau(U,q_lst,nq,Dim,navg):
    tau = np.zeros(nq)
    for i in range(nq):
        q = q_lst[i]
        I = IPR(U,q,Dim,navg) #IPR at q
        tau[i] = -np.log(I)/np.log(Dim) #scaling exponent
    return tau

#extrapolated scaling exponent
def Tau_ext(L_lst,Dim_lst,nl,nq,tau):
    tau_ext = np.zeros((nl-1,nq)) #scaling exponent at infinite size
    m = np.zeros((nl-1,nq)) #gradient of tau vs 1/lnN
    Dim_2 = int(Binom(L_lst[nl-1],L_lst[nl-1]/2)) #larger dimensionality
    for i in range(nl-1):
        x = 1/np.log(Dim_2)-1/np.log(Dim_lst[i])
        for j in range(nq):
            m[i,j] = (tau[nl-1,j]-tau[i,j])/x
            tau_ext[i,j] = tau[nl-1,j]-m[i,j]/np.log(Dim_2)
    return m,tau_ext

#Loop through system sizes
def Loops():
    L_lst,J,V,gamma,w,T_1,n,T_0,q_lst,navg,nq,nl = Parameters() #system parameters
    tau = np.zeros((nl,nq))
    Dim_lst = np.zeros(nl) #store dimensionalities
    for i in range(nl):
        L = L_lst[i] #update system size
        Dim_lst[i] = Binom(L,L/2) #dimensionality
        Dim = int(Dim_lst[i])
        H_1 = Offdiag(L,Dim,J) #off-diagonal part of Hamiltonian
        U = Eigenvectors(L,Dim,H_1,T_0,T_1,gamma,w,V,navg) #calculate eigenvectors
        tau[i] = Tau(U,q_lst,nq,Dim,navg) #calculate scaling exponent
    m,tau_ext = Tau_ext(L_lst,Dim_lst,nl,nq,tau) #calculate scaling exponents at infinite size
    return tau,m,tau_ext,Dim_lst

#plot scaling exponent extrapolation and infinite size exponents vs q
def Plots(tau,m,tau_ext,Dim_lst):
    L_lst,J,V,gamma,w,T_1,n,T_0,q_lst,navg,nq,nl = Parameters() #system parameters
    #extrapolations
    l_1 = L_lst[nl-2]
    l_2 = 200
    x_lst = np.zeros(2)
    x_lst[0] = int(Binom(l_1,l_1/2)) #first point
    x_lst[1] = int(Binom(l_2,l_2/2)) #second point (arbitrarily large)
    plt.figure(figsize=(8,6),dpi=80)
    plt.subplot(1,2,1) #plot scaling exponent extrapolation
    c = 0
    for i in range(1,nq,2):
        plt.plot(1/np.log(Dim_lst),tau[:,i],'C{}-x'.format(c),label=r'$q={}$'.format(np.round(q_lst[i],1)))
        plt.plot(1/np.log(x_lst),m[nl-2,i]/np.log(x_lst)+tau_ext[nl-2,i],'C{}--'.format(c))
        c = c+1
    plt.xlabel(r'$1/\ln\mathcal{D}$')
    plt.ylabel(r'$\tau_q$')
    plt.ylim([-1,2])
    plt.legend(ncol=2,fontsize=10)
    ax = plt.gca()
    plt.annotate('(i)',(0.92,0.03),xycoords='axes fraction')
    plt.annotate(r'$\gamma T_0/2\pi={}$'.format(n),(0.02,0.92),xycoords='axes fraction')
    ax.set_aspect(0.109)
    plt.subplot(1,2,2) #plot extrapolated scaling exponents vs q
    for i in range(nl-1):
        plt.plot(q_lst,tau_ext[i],'-x',label=r'$L\in[{},{}]$'.format(L_lst[i],L_lst[nl-1]))
    plt.axhline(y=0,linestyle='--',xmin=0.35,color='k'.format(i))
    plt.annotate('CUE',(0.89,0.86),xycoords='axes fraction')
    plt.annotate('Loc.',(0.9,0.28),xycoords='axes fraction')
    plt.annotate('(j)',(0.92,0.03),xycoords='axes fraction')
    plt.plot(q_lst,q_lst-1,'k--')
    plt.xlabel(r'$q$')
    plt.ylim([-1,2])
    plt.legend()
    plt.tight_layout()
    ax = plt.gca()
    ax.set_yticklabels([])
    ax.set_aspect(1)

#system parameters
def Parameters():
    L_lst = np.array([6,8,10,12,14,16]) #system sizes
    J = 0.5 #hopping amplitude
    V = 0.5 #interaction strength
    gamma = 5 #potential strength
    w = 0.05 #disorder strength
    T_1 = 0.1 #kicked period
    n = 0.5 #T_0 = 2πn/γ
    q_lst = np.linspace(0,3,16) #IPR moments
    navg = 3000 #total averaging (disorder realisations * evecs)
    return L_lst,J,V,gamma,w,T_1,n,2*np.pi/gamma*n,q_lst,navg,np.size(q_lst),np.size(L_lst)

tau,m,tau_ext,Dim_lst = Loops()
Plots(tau,m,tau_ext,Dim_lst)
