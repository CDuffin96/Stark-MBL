import numpy as np
import scipy.sparse as spr
import scipy.sparse.linalg as splng
import matplotlib.pyplot as plt
from numba import jit

#calculate dimensionality for half filling
@jit
def Binom(n,k):
    ret = 1
    for i in range(min(k,n-k)):
        ret *= n-i
        ret /= i+1
    return ret

#state to label
@jit
def S2L(L,l_vec):
    N = L/2
    l_counter = 1
    n_counter = N
    for i in range(L):
        if l_vec[i] == 0:
            l_counter += Binom(L-(i+1),n_counter-1)
        if l_vec[i] == 1:
            n_counter -= 1
        if n_counter == 0:
            return l_counter

#label to state
@jit
def L2S(L,l):
    N = L/2
    n_counter = N
    l_counter = l
    l_vec = np.zeros(L)
    for i in range(L):
        binom = Binom(L-(i+1),n_counter-1)
        if n_counter == 0:
            l_vec[i] = 0
            continue
        if l_counter > binom:
            l_vec[i] = 0
            l_counter -= binom
            continue
        if l_counter <= binom:
            l_vec[i] = 1
            n_counter -= 1
    return l_vec

#state to label for subsystem
@jit
def S2L_Binary(vec,l):
    c = 0
    for i in range(l):
        if vec[l-1-i] == 1:
            c += 2**i
    return c

#generate states via hopping terms
def Hop(L,input):
    input = np.ndarray.astype(input,int) #input state
    output_lst = [] #appended list of output states
    for i in range(L-1):
        if input[i] == 1 and input[i+1] == 0: #hopping to the right
            output = np.copy(input)
            output[i] = 0
            output[i+1] = 1
            output_lst.append(output)
        if input[i] == 0 and input[i+1] == 1: #hopping to the left
            output = np.copy(input)
            output[i] = 1
            output[i+1] = 0
            output_lst.append(output)
    ns = np.shape(output_lst)[0] #number of output states
    return output_lst,ns

#diagonal elements of static Hamiltonian
def Diag(L,Dim,gamma,w,V):
    row = np.empty(Dim*L)
    col = np.empty(Dim*L)
    data = np.empty(Dim*L)
    nnz = 0
    for i in range(Dim):
        state = L2S(L,i+1) #select vector
        v = 0 #nearest-neighbour interaction counter
        g = 0 #field interaction counter
        h = 0 #disorder interaction counter
        for k in range(L):
            g = g-gamma*k*state[k] #count field interactions
            h = h+np.random.normal(0,w)*state[k] #count disorder interactions
        for k in range(L-1):
            v = v+V*state[k]*state[k+1] #count nearest-neighbour interactions
        row[nnz] = i #H[i,i] = g+h+v
        col[nnz] = i
        data[nnz] = g+h+v
        nnz += 1
    return spr.csc_matrix((data[:nnz],(row[:nnz],col[:nnz])),shape=(Dim,Dim))

#off-diagonal elements of static Hamiltonian
def Offdiag(L,Dim,J):
    row = np.empty(Dim*L)
    col = np.empty(Dim*L)
    data = np.empty(Dim*L)
    nnz = 0
    for i in range(Dim):
        input = L2S(L,i+1) #generate Fock state
        output_lst,ns = Hop(L,input) #generate new states via hopping
        for k in range(ns): #loop through all states generated by hopping
            output = output_lst[k] #select output state
            j = int(S2L(L,output)-1) #convert to label
            row[nnz] = i #H[i,j] = J
            col[nnz] = j
            data[nnz] = J
            nnz += 1
    return spr.csc_matrix((data[:nnz],(row[:nnz],col[:nnz])),shape=(Dim,Dim))

#find states with N domains
def States(L,N,Dim):
    dw = np.zeros(Dim) #number of domain walls per Fock state
    for i in range(Dim):
        counter = 0
        vec = L2S(L,i+1) #generate Fock state vector
        for j in range(L-1): #count domain walls
            if vec[j+1] != vec[j]:
                counter += 1
        dw[i] = counter
    dn = np.where(dw == N)[0]+1 #find states with N domain walls
    return dn,np.size(dn)

#calculate time evolution of state vector
def Psi(L,Dim,T_0,T_1,H_0,H_1,states,p,x):
    psi = np.zeros((p,Dim),dtype=complex)
    s = states[x] #select state
    psi[0,s] = 1
    if L < 12: #time evolution via Floquet operator (smaller sizes)
        U_0 = splng.expm(-1j*T_0*H_0) #diagonal time evolution operator
        U_1 = splng.expm(-1j*T_1*H_1) #off-diagonal time evolution operator
        U = U_0@U_1 #Floquet operator
        for j in range(p-1):
            psi[j+1] = U@psi[j]
    else: #time evolution via sparse dynamics (larger sizes)
        for j in range(p-1):
            psi_1 = splng.expm_multiply(-1j*H_0,psi[j],start=0,stop=T_0,num=2,endpoint=True)[1]
            psi[j+1] = splng.expm_multiply(-1j*H_1,psi_1,start=0,stop=T_1,num=2,endpoint=True)[1]
    return psi

#bipartite entanglement entropy
def Entropy(Dim,L,psi):
    psi_full = np.zeros(2**L,dtype=complex)
    for i in range(Dim):
        vec = L2S(L,i+1).astype(int) #generate Fock state vector
        label = S2L_Binary(vec,L) #find label in full Hilbert space
        psi_full[label] = psi[i]
    psi_full = psi_full.reshape(2**int(L/2),2**int(L/2))
    s = scipy.linalg.svdvals(psi_full) #singular value decomposition
    s = s[s>10**(-20)]**2
    S = -np.inner(np.log(s),s) #entanglement entropy
    return S

def Saturation(L,gamma,w,V,J,T_0,T_1,N,p,n):
    Dim = int(Binom(L,L/2))
    states,nx = States(L,N,Dim)
    S = np.zeros((nx,p))
    H_0 = Diag(L,Dim,gamma,w,V) #diagonal part of Hamiltonian
    H_1 = Offdiag(L,Dim,J) #off-diagonal part of Hamiltonian
    for i in range(nx): #loop over initial states
        psi = Psi(L,Dim,T_0,T_1,H_0,H_1,states,p,i) #state vector
        for j in range(p): #loop over periods
            S[i,j] = Entropy(Dim,L,psi[j]) #bipartite entanglement entropy
    mS = np.mean(S,axis=0) #average over initial states
    phi = np.mean(mS[p-1-n:p-1]) #saturation point
    return mS,phi

def Loops():
    L_lst,N_lst,J,V,gamma,w,T_1,lst,T_0_lst,p,n,nl,ng = Parameters()
    S = np.zeros((nl,ng,p))
    phi = np.zeros((nl,ng))
    for i in range(nl):
        for j in range(ng):
            S[i,j],phi[i,j] = Saturation(L_lst[i],gamma,w,V,J,T_0_lst[j],T_1,N_lst[i],p,n)
    return S,phi

def Plot(S,phi):
    L_lst,N_lst,J,V,gamma,w,T_1,lst,T_0_lst,p,n,nl,ng = Parameters()
    plt.figure(figsize=(10,10),dpi=80)
    plt.subplot(1,2,1)
    for i in range(nl):
        plt.plot(S[i,1],label=r'$L={}$'.format(L_lst[i]))
    plt.xlabel('$t/T$')
    plt.ylabel('$S(t)$')
    plt.xscale('log')
    plt.annotate(r'$\gamma T_0/2\pi=1.0$',(0.02,0.2),xycoords='axes fraction')
    plt.annotate('(a)',(0.9,0.05),xycoords='axes fraction')
    plt.legend(ncol=2)
    ax = plt.gca()
    ax.set_aspect(1.05)
    plt.subplot(1,2,2)
    for i in range(ng):
        plt.plot(L_lst,phi[:,i],'C{} x'.format(i),label=r'$\gamma T_0/2\pi={}$'.format(lst[i]))
        m,c = np.polyfit(L_lst,phi[:,i],deg=1)
        plt.plot(L_lst,m*L_lst+c,'C{}--'.format(i))
    plt.xlabel('$L$')
    plt.ylabel(r'$S_{\infty}$')
    plt.annotate('(b)',(0.9,0.1),xycoords='axes fraction')
    plt.legend()
    ax = plt.gca()
    ax.set_aspect(16/5)

def Parameters():
    L_lst = np.array([6,8,10,12,14,16]) #system size
    N_lst = L_lst-3 #number of domains
    J = 0.5 #hopping amplitude
    V = 0.5 #interaction strength
    gamma = 5 #potential strength
    w = 0.05 #disorder
    T_1 = 0.1 #kicked period
    lst = np.array([0.5,1])
    T_0_lst = 2*np.pi*lst/gamma #unkicked period
    #time parameters
    p = 2000 #number of periods
    n = int(p/10) #periods to average over
    return L_lst,N_lst,J,V,gamma,w,T_1,lst,T_0_lst,p,n,np.size(L_lst),np.size(lst)

#S,phi = Loops()
Plot(S,phi)
