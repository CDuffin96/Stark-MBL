import numpy as np
from sympy.utilities.iterables import multiset_permutations
import scipy.special
import scipy.sparse as spr
import scipy.sparse.linalg as splng
from scipy.ndimage import gaussian_filter1d
import matplotlib.pyplot as plt
from numba import jit

@jit
def Binom(n,k):
    ret = 1
    for i in range(min(k,n-k)):
        ret *= n-i
        ret /= i+1
    return ret

#state to label
@jit
def S2L(L,l_vec):
    N = L/2
    l_counter = 1
    n_counter = N
    for i in range(L):
        if l_vec[i] == 0:
            l_counter += Binom(L-(i+1),n_counter-1)
        if l_vec[i] == 1:
            n_counter -= 1
        if n_counter == 0:
            return l_counter

#label to state
@jit
def L2S(L,l):
    N = L/2
    n_counter = N
    l_counter = l
    l_vec = np.zeros(L)
    for i in range(L):
        binom = Binom(L-(i+1),n_counter-1)
        if n_counter == 0:
            l_vec[i] = 0
            continue
        if l_counter > binom:
            l_vec[i] = 0
            l_counter -= binom
            continue
        if l_counter <= binom:
            l_vec[i] = 1
            n_counter -= 1
    return l_vec

#state to label for subsystem
@jit
def S2L_Binary(vec,l):
    c = 0
    for i in range(l):
        if vec[l-1-i] == 1:
            c += 2**i
    return c

#perform hopping operations
def Hop(a):
    a = np.ndarray.astype(a,int)
    b_lst = []
    for i in range(L-1):
        if a[i] == 1 and a[i+1] == 0: #hopping to the right
            b = np.copy(a)
            b[i] = 0
            b[i+1] = 1
            b_lst.append(b)
        if a[i] == 0 and a[i+1] == 1: #hopping to the left
            b = np.copy(a)
            b[i] = 1
            b[i+1] = 0
            b_lst.append(b)
    if a[L-1] == 1 and a[0] == 0: #open boundaries right
        b = np.copy(a)
        b[L-1] = 0
        b[0] = 1
        b_lst.append(b)
    if a[L-1] == 0 and a[0] == 1: #open boundaries left
        b = np.copy(a)
        b[L-1] = 1
        b[0] = 0
        b_lst.append(b)
    ns = np.shape(b_lst)[0]
    return b_lst,ns

#diagonal elements
def Diag():
    Dim = int(Binom(L,L/2))
    row = np.empty(Dim*L)
    col = np.empty(Dim*L)
    data = np.empty(Dim*L)
    nnz = 0
    for i in range(Dim):
        A = L2S(L,i+1) #select vector
        v = 0 #nearest-neighbour interaction counter
        g = 0 #field interaction counter
        h = 0 #disorder interaction counter
        for k in range(L):
            g = g-gamma*k*A[k] #count field interactions
            h = h+np.random.normal(0,w)*A[k] #count disorder interactions
        for k in range(L-1):
            v = v+V*A[k]*A[k+1] #count nearest-neighbour interactions
        v = v+V*A[L-1]*A[0] #open boundary interaction
        row[nnz] = i
        col[nnz] = i
        data[nnz] = g+h+v
        nnz += 1
    return spr.coo_matrix((data[:nnz],(row[:nnz],col[:nnz])),shape=(Dim,Dim))

#off-diagonal elements
def Offdiag():
    Dim = int(Binom(L,L/2))
    row = np.empty(Dim*L)
    col = np.empty(Dim*L)
    data = np.empty(Dim*L)
    nnz = 0
    for i in range(Dim):
        A = L2S(L,i+1) #generate Fock state
        B_lst,ns = Hop(A) #perform hopping
        for k in range(ns): #loop through all states generated by hopping
            B = B_lst[k]
            j = int(S2L(L,B)-1) #convert to label
            row[nnz] = i
            col[nnz] = j
            data[nnz] = J
            nnz += 1
    return spr.coo_matrix((data[:nnz],(row[:nnz],col[:nnz])),shape=(Dim,Dim))

def Neel():
    a = np.zeros(L)
    for i in range(0,L,2):
        a[i] = 1
    l = S2L(L,a)
    return int(l)

def Psi(T_0):
    H_Offdiag = Offdiag()
    psi = np.zeros((nt+1,Dim),dtype=complex)
    X = Neel() #NÃ©el state
    psi[0,X] = 1 #initial state
    H_Diag = Diag()
    H_0 = H_Diag #Hamiltonian 0
    H_1 = H_Diag+H_Offdiag #Hamiltonian 1
    q_0 = int(q*T_0/(T_0+T_1)) #increments inside first half period
    q_1 = q-q_0 #increments inside second half period
    for i in range(p):
        a = i*q #increment at start of period
        b = i*q+q_0 #increment halfway through period
        c = q*(i+1) #increment at end of period
        psi[a:b+1] = splng.expm_multiply(-1j*H_0,psi[a],start=0,stop=T_0,num=q_0+1,endpoint=True)
        psi[b:c+1] = splng.expm_multiply(-1j*H_1,psi[b],start=0,stop=T_1,num=q_1+1,endpoint=True)
    return psi

#bipartite entanglement entropy
def Entropy(psi):
    psi_full = np.zeros(2**L,dtype=complex)
    for i in range(Dim):
        vec = L2S(L,i+1).astype(int) #generate Fock state vector
        label = S2L_Binary(vec,L) #find label in full Hilbert space
        psi_full[label] = psi[i]
    psi_full = psi_full.reshape(2**int(L/2),2**int(L/2))
    s = scipy.linalg.svdvals(psi_full) #singular value decomposition
    s = s[s>10**(-20)]**2
    S = -np.inner(np.log(s),s) #entanglement entropy
    return S

#Parameters
L = 22 #system size
J = 0.5 #hopping amplitude
V = 0.5 #interaction strength
gamma = 5 #potential strength
w = 0.05 #disorder
T_1 = 0.1 #kicked period
lst = np.array([0.2,0.5,1,1.5,2])
T_0_lst = 2*np.pi*lst/gamma #unkicked period

#Time parameters
p = 20 #number of periods
q = 10 #increments inside full period
nt = p*q #time increments
t = np.linspace(0,p,nt) #time domain

Dim = int(Binom(L,L/2)) #dimensionality
l = int(L/2) #subsystem size
ng = np.size(T_0_lst)
S = np.zeros((ng,nt))
sS = np.zeros((ng,nt))

for i in range(ng):
    psi = Psi(T_0_lst[i])
    for j in range(nt):
        S[i,j] = Entropy(psi[j])

m_0,c_0 = np.polyfit(t,S[2],deg=1)
m_1,c_1 = np.polyfit(t,S[4],deg=1)
for i in range(ng):
    plt.plot(t[0:nt:q],S[i,0:nt:q],label=r'$\gamma T_0/2\pi={}$'.format(lst[i]))
plt.plot(t[15:nt:q],m_0*t[15:nt:q]+c_0,'C2--')
plt.plot(t[15:nt:q],m_1*t[15:nt:q]+c_1,'C4--')
plt.xlabel(r'$t/T$')
plt.ylabel(r'$S(t)$')
plt.legend()
